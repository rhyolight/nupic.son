# Copyright 2012 the Melange authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Query and functions for Connection.
"""

from django.utils import translation

from melange.logic import connection_message as connection_message_logic
from melange.models import connection as connection_model
from melange.utils import rich_bool


_CONNECTION_EXISTS = translation.ugettext(
    'Connection between %s and %s already exists.')

_PROFILE_IS_STUDENT = translation.ugettext(
    'Profile %s is a student.')

def queryForAncestor(ancestor, keys_only=False):
  """Returns a Query object for Connections with the specified ancestor.
  """
  return connection_model.Connection.all(keys_only=keys_only).ancestor(ancestor)

def queryForAncestorAndOrganization(ancestor, organization, keys_only=False):
  """Returns a Query object for Connections with the specified ancestor and
  Organization.
  """
  query = connection_model.Connection.all(
      keys_only=keys_only).ancestor(ancestor)
  query.filter('organization', organization)
  return query


def queryForOrganizationAdmin(profile):
  """Returns a query to fetch all connection entities that can be managed
  from organization perspective by the specified profile.

  Args:
    profile: profile entity.

  Returns:
    db.Query object to fetch all connection entities to manage.
  """
  query = connection_model.Connection.all()
  query.filter('organization IN', profile.org_admin_for)
  return query


def connectionExists(profile, organization):
  """Check to see whether or not a Connection exists between a user and
  an organization.

  Args:
    profile: Profile instance (parent) for the connection.
    organization: Organization for the connection.

  Returns:
    True if a Connection object exists for the given User and
    Organization, else False.
  """
  query = queryForAncestorAndOrganization(profile, organization, True)
  return query.count(limit=1) > 0


def canCreateConnection(profile, org_key):
  """Tells whether a connection between the specified profile and organization
  can be created.

  Args:
    profile: profile entity.
    org_key: organization key.

  Returns:
    RichBool whose value is set to True, if a connection can be created.
    Otherwise, RichBool whose value is set to False and extra part is
    a string that represents the reason why it is not possible to create
    a new connection.
  """
  if profile.is_student:
    return rich_bool.RichBool(
        False, extra=_PROFILE_IS_STUDENT % profile.link_id)
  elif connectionExists(profile, org_key):
    return rich_bool.RichBool(
        False, extra=_CONNECTION_EXISTS % (profile.link_id, org_key.name()))
  else:
    return rich_bool.TRUE


def createConnection(profile, org, user_role, org_role):
  """Create a new Connection instance based on the contents of the form
  and the roles provided.

  Args:
    profile: Profile with which to establish the connection.
    org: Organization with which to establish the connection.
    user_role: The user's role for the connection.
    org_role: The org's role for the connection.

  Returns:
      Newly created Connection instance.

  Raises:
      ValueError if a connection exists between the user and organization.
  """
  if connectionExists(profile.parent_key(), org):
    raise ValueError(_CONNECTION_EXISTS % (profile.name(), org.name))

  connection = connection_model.Connection(parent=profile, organization=org)
  connection.user_role = user_role
  connection.org_role = org_role
  connection.put()

  return connection


def createConnectionMessage(connection_key, content, author_key=None):
  """Create a new ConnectionMessage to represent a message left
  on the specified connection.

  Args:
    connection: connection key.
    content: message content as a string
    author_key: profile key of the user who is the author of the message. 
      If set to None, the message is considered auto-generated by the system.

  Returns:
    Newly created ConnectionMessage entity.
  """
  message = connection_model.ConnectionMessage(
      parent=connection_key, content=content, author=author_key,
      is_auto_generated=not bool(author_key))
  message.put()

  return message


def getConnectionMessages(connection, limit=1000):
  """Returns messages for the specified connection

  Args:
    connection: the specified Connection entity
    limit: maximal number of results to return

  Returns:
    list of messages corresponding to the specified connection
  """
  builder = connection_message_logic.QueryBuilder()
  return builder.addAncestor(connection).setOrder('created').build().fetch(
      limit=limit)